using CapriKit.Generators.PrecisionVariants;
using CapriKit.Tests.TestUtilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace CapriKit.Tests.Generators.PrecisionVariants;

internal class VariantGeneratorTests
{
    [Test]
    public async Task FOoBar()
    {
        IEnumerable<(string fileName, SourceText content)> emptySource = [];
        IEnumerable<(string fileName, SourceText content)> generatedFiles =
        [
            new (@"CapriKit.Generators.PrecisionVariants\CapriKit.Generators.PrecisionVariants.AttributeGenerator\Microsoft.CodeAnalysis.EmbeddedAttribute.cs", SourceText.From(EmbeddedSource, Encoding.UTF8)),
            new (@"CapriKit.Generators.PrecisionVariants\CapriKit.Generators.PrecisionVariants.AttributeGenerator\GeneratePrecisionVariantAttributes.g.cs", SourceText.From(AttributeSource, Encoding.UTF8))
        ];

        // TODO: create a special type that we can assert on the generator instead of some input
        // Use chaining to automatically add the embedded attribute and add the input and output stuff
        // See: https://tunit.dev/docs/assertions/extensibility/extensibility-chaining-and-converting
        await Assert.That(emptySource).GeneratesFiles<AttributeGenerator>(generatedFiles);


        // await Assert.That(SourceGenerator.OfType<X>())
        //  .WithInputSourceFiles(emptySource)
        //  .WithInputAdditionalFiles(emptySource)
        //  .Generates(generatedFiles, generatedDiagnostics);
    }


    private static readonly string AttributeSource = """
            using System;
            using Microsoft.CodeAnalysis;

            namespace CapriKit.PrecisionVariants
            {
                [Embedded]
                [AttributeUsage(AttributeTargets.Method)]
                internal sealed class GenerateFloatVariant : Attribute { }

            }
            """;

    private static readonly string EmbeddedSource = """
            // <auto-generated/>
            namespace Microsoft.CodeAnalysis
            {
                internal sealed partial class EmbeddedAttribute : global::System.Attribute
                {
                }
            }
            """;

    [Test]
    public async Task Execute_ComplexTypeVariants_RewritesAllTypesToFullyQualifiedNames()
    {
        var variantGenerator = new VariantGenerator();
        var source = AttributeSource + """
            namespace Test.Namespace
            {
                using CapriKit.PrecisionVariants;

                internal static partial class TestClass
                {
                    [GenerateFloatVariant]
                    internal static Array? TestMethod(object obj, List<Array> generic, Array[] array, (Array a, Array b) tuple)
                    {
                        double sum = 0.0;
                        double? x = Math.Sin(1.0);
                        unsafe
                        {
                            Array* pointer = null;
                        }
                        return null;
                    }
                }
            }
            """;
        var result = variantGenerator.Execute(source);

        await Assert.That(result.Diagnostics.Length).IsZero();
        await Assert.That(result.GeneratedFiles.Length).IsEqualTo(1);

        var expected = """
            namespace Test.Namespace
            {
                partial class TestClass
                {
                    [global::CapriKit.PrecisionVariants.GenerateFloatVariant]
                    internal static global::System.Array? TestMethod(object obj, global::System.Collections.Generic.List<global::System.Array> generic, global::System.Array[] array, (global::System.Array a, global::System.Array b) tuple)
                    {
                        float sum = 0F;
                        float? x = global::System.MathF.Sin(1F);
                        unsafe
                        {
                            global::System.Array* pointer = null;
                        }

                        return null;
                    }
                }
            }
            """;

        var generatedFile = result.GeneratedFiles[0].Source.ToString();
        await Assert.That(generatedFile).IsEqualTo(expected).IgnoringWhitespace();
    }

    // TODO: it would be easier to test source generators using Microsoft.CodeAnalysis.Testing
    // but that doesn't work with the latest source generators
    // see: https://github.com/dotnet/roslyn-sdk/issues/1241
    // and: https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md

    //[Test]
    //public async Task Execute_MethodWithAttribute_IsRewritten2()
    //{
    //    var source = """
    //            using System;
    //            using Microsoft.CodeAnalysis;

    //            namespace CapriKit.PrecisionVariants
    //            {
    //                [Embedded]
    //                [AttributeUsage(AttributeTargets.Method)]
    //                internal sealed class GenerateFloatVariant : Attribute { }

    //                internal static partial class Statistics
    //                {
    //                    [CapriKit.PrecisionVariants.GenerateFloatVariant]
    //                    public static double StandardError(double standardDeviation, double count)
    //                    {
    //                        return standardDeviation / Math.Sqrt(count);
    //                    }
    //                }
    //            }                     
    //            """;

    //    var test = new CSharpSourceGeneratorTest<VariantGenerator, FooVerifier>
    //    {
    //        TestState =
    //        {
    //            Sources = { source },
    //            GeneratedSources =
    //            {
    //                (typeof(VariantGenerator), "Hello.g.cs", "")
    //            }
    //        }
    //    };

    //    await test.RunAsync();
    //}
}
