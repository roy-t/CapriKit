using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics;

namespace CapriKit.CommandLine;

[Generator]
public class VerbGenerator : IIncrementalGenerator
{
    private static string VerbAttributeFullName = "CapriKit.CommandLine.Types.VerbAttribute";
    private static string VerbAttributeName = "VerbAttribute";

    private static string FlagAttributeFullName = "CapriKit.CommandLine.Types.FlagAttribute";
    private static string FlagAttributeName = "FlagAttribute";
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var declarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            VerbAttributeFullName,
            static (node, _) => node is ClassDeclarationSyntax,
            static (ctx, ct) => GetSemanticTargetForGeneration(ctx, ct));            

        context.RegisterSourceOutput(declarations, static (spc, source) => GenerateVerbClass(source.Syntax, source.Data, spc));
    }

    // TODO: this now succesfully parses the attribute and the attribute list but needs to generate code
    // TODO: need to parse the flag attribute, clean-up 

    private static void GenerateVerbClass(ClassDeclarationSyntax? syntax, AttributeData? data, SourceProductionContext spc)
    {        
        var id = "";
        var documentation = "";
        if(syntax != null)
        {            
            id = syntax.Identifier.Text;
            if (syntax.HasLeadingTrivia)
            {                
                var trivia = syntax.GetLeadingTrivia(); //SyntaxTrivia SingleLineDocumentationCommentTrivia
                foreach(var t in trivia)
                {
                    var kind = t.Kind();
                    if(kind == SyntaxKind.SingleLineDocumentationCommentTrivia || kind == SyntaxKind.MultiLineDocumentationCommentTrivia)
                    {
                        documentation = t.ToString();
                    }
                }
            }
        }

        var arg = "";
        if(data != null)
        {
            arg = data.ConstructorArguments[0].Value?.ToString();
        }
        
        spc.AddSource("generated.g.cs",
            $"""
            // <auto-generated/>
            using System;
            // Found id: {id}, and arg is: {arg}
            /** documentation:
            {documentation}
            **/
            """
        );
    }

    private static (ClassDeclarationSyntax? Syntax, AttributeData? Data) GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        if (!(context.TargetNode is ClassDeclarationSyntax classDeclaration))
            return (null, null);
        
        var attribute = context.Attributes.FirstOrDefault(a => a.AttributeClass?.Name == VerbAttributeName);                
        return (classDeclaration, attribute);
    }
}
